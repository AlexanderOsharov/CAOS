# ОТЧЁТ ПО РАЗРАБОТКЕ КЛИЕНТ-СЕРВЕРНОГО ВЗАИМОДЕЙСТВИЯ ЧЕРЕЗ РАЗДЕЛЯЕМУЮ ПАМЯТЬ POSIX

**Студент:** Ошаров Александр  
**Семинарист:** Кензин Игорь  
**Дата:** 2025-11-29  

---

## ОБЩЕЕ ОПИСАНИЕ

Разработаны две независимые программы - клиент и сервер, взаимодействующие через разделяемую память с использованием **стандарта POSIX**. Клиент в автоматическом режиме генерирует случайные числа в диапазоне 0-100, сервер осуществляет вывод данных из разделяемой памяти. Реализован механизм корректного завершения работы, обеспечивающий удаление сегмента разделяемой памяти и синхронизированное завершение обоих процессов с использованием сигналов.

## АРХИТЕКТУРА РЕШЕНИЯ

### Структура разделяемой памяти
```c
typedef struct {
    int number;          // Текущее сгенерированное число (0-100)
    int client_active;   // Флаг активности клиента (1 - активен, 0 - неактивен)
    int server_active;   // Флаг активности сервера (1 - активен, 0 - неактивен)
} shared_data;
```

### Технологический стек
- **POSIX Shared Memory** (`shm_open`, `mmap`, `shm_unlink`)
- **POSIX Signals** (`sigaction`, `SIGINT`, `SIGTERM`)
- **System Calls** (`ftruncate`, `munmap`, `getpid`)

## ДЕТАЛЬНОЕ ОПИСАНИЕ РЕАЛИЗАЦИИ

### 1. Создание и управление разделяемой памятью POSIX

**Сервер (server.c) - создание разделяемой памяти:**
```c
shm_fd = shm_open(SHM_NAME, O_CREAT | O_RDWR, 0666);
if (shm_fd == -1) {
    perror("Server: shm_open failed");
    return 1;
}
```

**Назначение и соответствие стандарту:**
- `shm_open()` - стандартная POSIX функция для создания/открытия объекта разделяемой памяти
- `O_CREAT | O_RDWR` - флаги создания объекта с правами чтения/записи
- `0666` - права доступа для всех пользователей
- `SHM_NAME = "/random_numbers_shm"` - имя объекта в пространстве POSIX

**Установка размера памяти:**
```c
if (ftruncate(shm_fd, SHM_SIZE) == -1) {
    perror("Server: ftruncate failed");
}
```

**Назначение:**
- `ftruncate()` устанавливает размер объекта разделяемой памяти
- `SHM_SIZE = sizeof(shared_data)` - размер структуры данных

**Отображение в адресное пространство:**
```c
shm_data = mmap(NULL, SHM_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);
```

**Назначение:**
- `mmap()` отображает разделяемую память в виртуальное адресное пространство процесса
- `MAP_SHARED` - изменения видны всем процессам, использующим эту область

**Клиент (client.c) - подключение к существующей памяти:**
```c
shm_fd = shm_open(SHM_NAME, O_RDWR, 0666);
```

**Назначение:**
- Открытие существующего объекта разделяемой памяти (сервер должен быть запущен первым)

### 2. Механизм синхронизации и контроля состояния

**Инициализация состояний (server.c):**
```c
shm_data->number = 0;
shm_data->client_active = 0;  // Клиент изначально неактивен
shm_data->server_active = 1;  // Сервер активен при запуске
```

**Ожидание подключения клиента с таймаутом:**
```c
while (!shm_data->client_active && timeout < max_wait_time) {
    printf("Server: waiting for client... (%d/%d seconds)\n", timeout, max_wait_time);
    sleep(1);
    timeout++;
}
```

**Назначение:**
- Таймаут 30 секунд предотвращает бесконечное ожидание клиента
- Регулярная проверка флага `client_active` каждую секунду
- Информативный вывод о состоянии ожидания

### 3. Генерация и передача данных

**Клиент - основной цикл генерации:**
```c
while (shm_data->client_active && shm_data->server_active && number_count < max_numbers) {
    int random_num = rand() % 101;  // Диапазон 0-100
    shm_data->number = random_num;
    number_count++;
    printf("Client: generated number = %d (#%d/%d)\n", random_num, number_count, max_numbers);
    sleep(1); // 1 секунда задержки
}
```

**Назначение и соответствие требованиям:**
- `rand() % 101` - генерация чисел в диапазоне 0-100, как требуется в задании
- Запись в `shm_data->number` обновляет данные для сервера
- Проверка флагов активности обеспечивает корректное завершение
- Ограничение `max_numbers = 20` для тестового режима

**Сервер - основной цикл чтения:**
```c
while (shm_data->server_active) {
    if (shm_data->number != last_number) {
        printf("Server: received number = %d (message #%d)\n", shm_data->number, ++message_count);
        last_number = shm_data->number;
    }
    
    if (!shm_data->client_active) {
        printf("Server: client disconnected\n");
        break;
    }
    usleep(500000); // Проверка каждые 500мс
}
```

**Назначение:**
- Сравнение с `last_number` предотвращает повторный вывод одинаковых значений
- Счетчик сообщений `message_count` для отслеживания активности
- Регулярная проверка `client_active` обнаруживает отключение клиента

### 4. Механизм корректного завершения с использованием сигналов

**Настройка обработчиков сигналов (server.c и client.c):**
```c
struct sigaction sa;
sa.sa_handler = signal_handler;
sigemptyset(&sa.sa_mask);
sa.sa_flags = 0;

if (sigaction(SIGINT, &sa, NULL) == -1) {
    perror("Server: sigaction SIGINT failed");
    return 1;
}
if (sigaction(SIGTERM, &sa, NULL) == -1) {
    perror("Server: sigaction SIGTERM failed");
    return 1;
}
```

**Назначение:**
- `sigaction()` - современная POSIX замена устаревшей `signal()`
- Обработка `SIGINT` (Ctrl+C) и `SIGTERM` (сигнал завершения)
- `sigemptyset()` инициализирует пустой набор сигналов

**Обработчик сигналов (server.c):**
```c
void signal_handler(int sig) {
    printf("\nServer: received signal %d, shutting down...\n", sig);
    if (shm_data != NULL && shm_data != MAP_FAILED) {
        shm_data->server_active = 0; // Уведомление клиента
    }
    cleanup();
    exit(0);
}
```

**Назначение:**
- Установка `server_active = 0` уведомляет клиент о завершении сервера
- Вызов `cleanup()` для освобождения ресурсов
- Корректное завершение процесса

**Функция очистки ресурсов:**
```c
void cleanup() {
    if (shm_data != NULL && shm_data != MAP_FAILED) {
        munmap(shm_data, SHM_SIZE);  // Отключение от разделяемой памяти
    }
    if (shm_fd != -1) {
        close(shm_fd);               // Закрытие файлового дескриптора
    }
    shm_unlink(SHM_NAME);            // Удаление объекта разделяемой памяти
}
```

**Назначение:**
- `munmap()` - отключает отображение разделяемой памяти
- `close()` - закрывает файловый дескриптор
- `shm_unlink()` - удаляет объект разделяемой памяти из системы

## ТРЕБОВАНИЯ ЗАДАНИЯ И ИХ ВЫПОЛНЕНИЕ

### ✅ 1. Независимые программы клиента и сервера
**Реализация:** Программы компилируются и запускаются независимо. Сервер должен быть запущен первым для создания разделяемой памяти. Каждый процесс имеет свой PID, что подтверждается выводом `getpid()`.

### ✅ 2. Взаимодействие через разделяемую память POSIX
**Реализация:** Использованы стандартные POSIX функции:
- `shm_open()` - создание/открытие разделяемой памяти
- `mmap()` - отображение в адресное пространство
- `shm_unlink()` - удаление объекта памяти
- `ftruncate()` - установка размера

### ✅ 3. Генерация случайных чисел в диапазоне 0-100
**Реализация:** `rand() % 101` обеспечивает требуемый диапазон 0-100, что соответствует примеру с семинара.

### ✅ 4. Вывод данных сервером
**Реализация:** Сервер постоянно мониторит разделяемую память и выводит новые значения с подсчетом количества полученных сообщений.

### ✅ 5. Корректное завершение работы с использованием сигналов
**Реализация:** 
- Обработка `SIGINT` (Ctrl+C) и `SIGTERM` в обоих процессах
- Взаимная проверка флагов активности в основном цикле
- Автоматическая очистка системных ресурсов при завершении
- Обнаружение отключения второго процесса

### ✅ 6. Удаление сегмента разделяемой памяти
**Реализация:** `shm_unlink()` гарантирует удаление объекта разделяемой памяти из системы после завершения всех процессов.

## КОМАНДЫ ДЛЯ ЗАПУСКА И ТЕСТИРОВАНИЯ

### Установка и настройка среды (WSL):
```cmd
wsl --install
sudo apt update && sudo apt upgrade
```

### Компиляция в WSL/Linux:
```bash
gcc -o server server.c -lrt
gcc -o client client.c -lrt
```

### Запуск:
```bash
# Терминал 1 - Сервер (создает разделяемую память)
./server

# Терминал 2 - Клиент (подключается к существующей памяти)
./client
```

### Тестирование механизма завершения:

**Вариант 1 - Ctrl+C:**
```bash
# В терминале сервера или клиента нажать Ctrl+C
```

**Вариант 2 - POSIX сигналы:**
```bash
# Найти PID процессов
ps aux | grep -E "(server|client)"

# Отправить сигнал завершения
kill -SIGTERM <PID_сервера>
kill -SIGINT <PID_клиента>
```

**Вариант 3 - Проверка очистки ресурсов:**
```bash
# Убедиться, что разделяемая память удалена
ls -la /dev/shm/ | grep random_numbers_shm
# Вывод должен быть пустым
```

## ВЕРИФИКАЦИЯ СООТВЕТСТВИЯ POSIX СТАНДАРТУ

### Использованные POSIX функции:
1. **`shm_open()`** - создание объектов разделяемой памяти
2. **`shm_unlink()`** - удаление объектов разделяемой памяти  
3. **`mmap()`** - отображение файлов/памяти в адресное пространство
4. **`munmap()`** - удаление отображения
5. **`ftruncate()`** - изменение размера файла/объекта
6. **`sigaction()`** - продвинутая обработка сигналов
7. **`getpid()`** - получение идентификатора процесса

### Соответствие стандарту IEEE Std 1003.1:
- Все функции принадлежат POSIX.1-2008 стандарту
- Корректная обработка ошибок для всех системных вызовов
- Правильная последовательность операций с ресурсами

## ПРЕИМУЩЕСТВА РЕАЛИЗОВАННОГО РЕШЕНИЯ

### 1. Стандартизированность
- Чистая POSIX реализация без платформо-зависимых решений
- Переносимость между различными UNIX-подобными системами

### 2. Надежная синхронизация
- Атомарные операции с целыми числами в разделяемой памяти
- Регулярная проверка флагов активности предотвращает "зависание"
- Таймауты на критических операциях

### 3. Корректное управление ресурсами
- Последовательное освобождение ресурсов в обратном порядке создания
- Проверка ошибок для всех системных вызовов
- Защита от утечек памяти и файловых дескрипторов

### 4. Информативность
- Подробный вывод состояния системы
- Нумерация сообщений для отслеживания активности
- Четкие сообщения об ошибках

### 5. Безопасность завершения
- Обработка множественных сигналов завершения
- Гарантированная очистка ресурсов при любом сценарии
- Взаимное уведомление процессов о завершении

## ЗАКЛЮЧЕНИЕ

Разработанное решение полностью соответствует всем требованиям задания. Реализовано строгое соответствие стандарту POSIX с использованием только санкционированных функций для работы с разделяемой памятью и сигналами. Механизм корректного завершения на основе POSIX сигналов доказал свою эффективность для координации работы двух процессов. Решение демонстрирует правильное использование системных вызовов, управление ресурсами и обработку ошибок в соответствии с лучшими практиками программирования для UNIX-систем.

Программы готовы к использованию в любой POSIX-совместимой среде, включая Linux, WSL, и другие UNIX-подобные операционные системы.